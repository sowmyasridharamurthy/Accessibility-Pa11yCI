'use strict';

const { assert } = require('@sindresorhus/is');

const levels = Object.freeze({
    info: 'info',
    warn: 'warn',
    error: 'error'
});

const getOriginalLogEntryDefaults = () => Object.freeze({
    errorCode: 1,
    exitOnError: true,
    isResult: false,
    level: levels.info,
    resultPrefix: '\u2BA1'
});

let logEntryDefaults = getOriginalLogEntryDefaults();

const validateAndAddSetting = (args, property, type, result) => {
    // A setting could allow a falsy value, so check for the existence of the property
    if (Object.keys(args).includes(property)) {
        // Call the specified assert type function, which will throw on type error
        assert[type](args[property]);
        result[property] = args[property];
    }
};

const validateLogSettings = (args) => {
    const result = {};

    validateAndAddSetting(args, 'errorCode', 'integer', result);
    validateAndAddSetting(args, 'exitOnError', 'boolean', result);
    validateAndAddSetting(args, 'isResult', 'boolean', result);
    validateAndAddSetting(args, 'resultPrefix', 'string', result);

    if (Object.keys(args).includes('level')) {
        if (!Object.values(levels).includes(args.level)) {
            throw new TypeError(`Level must be a valid enumeration (${Object.values(levels).join(', ')})`);
        }
        result.level = args.level;
    }

    return Object.assign(Object.create(null), logEntryDefaults, result);
};

const setLogEntryDefaults = (settings) => {
    logEntryDefaults = validateLogSettings(settings);
};

const resetLogEntryDefaults = () => {
    logEntryDefaults = getOriginalLogEntryDefaults();
};

const getLogEntry = (args) => {
    assert.object(args);
    assert.string(args.message);

    return {
        ...validateLogSettings(args),
        message: args.message
    };
};

const getLogMethod = (level) => {
    let logMethod;
    switch (level) {
        case levels.warn:
            logMethod = console.warn;
            break;
        case levels.error:
            logMethod = console.error;
            break;
        case levels.info:
        default:
            logMethod = console.log;
            break;
    }
    return logMethod;
};

const log = (args) => {
    const logEntry = getLogEntry(args);
    const logMethod = getLogMethod(logEntry.level);

    let { message } = logEntry;
    if (logEntry.isResult) {
        message = ` ${logEntry.resultPrefix} ${logEntry.message}`;
    }

    logMethod(message);

    if (logEntry.level === levels.error && logEntry.exitOnError) {
        console.error(`Fatal error - exiting (${logEntry.errorCode})`);
        // For CI jobs, want process to exit with appropriate error cede.
        // eslint-disable-next-line no-process-exit
        process.exit(logEntry.errorCode);
    }
};

module.exports.levels = levels;
module.exports.log = log;
module.exports.getLogEntry = getLogEntry;
module.exports.resetLogEntryDefaults = resetLogEntryDefaults;
module.exports.setLogEntryDefaults = setLogEntryDefaults;
