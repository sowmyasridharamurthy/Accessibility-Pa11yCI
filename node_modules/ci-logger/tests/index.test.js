/* eslint-disable max-lines */
'use strict';

const logger = require('../index');

const message = 'something';

const originalLogEntryDefaults = Object.freeze({
    errorCode: 1,
    exitOnError: true,
    isResult: false,
    level: logger.levels.info,
    resultPrefix: '\u2BA1'
});

// eslint-disable-next-line max-lines-per-function
describe('get log entry', () => {
    it('should throw if invalid args provided', () => {
        expect.assertions(1);
        expect(() => logger.getLogEntry()).toThrow(/undefined/);
    });

    it('should throw if args has invalid message', () => {
        expect.assertions(1);
        expect(() => logger.getLogEntry({})).toThrow(/string/);
    });

    it('should populate logEntry with message', () => {
        expect.assertions(1);
        const logInput = { message };
        const logEntry = logger.getLogEntry(logInput);
        expect(logEntry.message).toStrictEqual(logInput.message);
    });

    it('should not throw if args has valid message', () => {
        expect.assertions(1);
        const logInput = { message };
        expect(() => logger.getLogEntry(logInput)).not.toThrow();
    });

    it('should populate logEntry with errorCode if provided', () => {
        expect.assertions(1);
        const logInput = { message, errorCode: originalLogEntryDefaults.errorCode + 1 };
        const logEntry = logger.getLogEntry(logInput);
        expect(logEntry.errorCode).toStrictEqual(logInput.errorCode);
    });

    it('should populate logEntry with default errorCode if not provided', () => {
        expect.assertions(1);
        const logInput = { message };
        const logEntry = logger.getLogEntry(logInput);
        expect(logEntry.errorCode).toStrictEqual(originalLogEntryDefaults.errorCode);
    });

    it('should throw if invalid errorCode is provided', () => {
        expect.assertions(1);
        const logInput = { message, errorCode: '3' };
        expect(() => logger.getLogEntry(logInput)).toThrow('integer');
    });

    it('should populate logEntry with level if provided and valid', () => {
        expect.assertions(3); // eslint-disable-line no-magic-numbers
        const logInput = { message, level: logger.levels.info };
        let logEntry = logger.getLogEntry(logInput);
        expect(logEntry.level).toStrictEqual(logInput.level);

        logInput.level = logger.levels.warn;
        logEntry = logger.getLogEntry(logInput);
        expect(logEntry.level).toStrictEqual(logInput.level);

        logInput.level = logger.levels.error;
        logEntry = logger.getLogEntry(logInput);
        expect(logEntry.level).toStrictEqual(logInput.level);
    });

    it('should populate logEntry with default level if not provided', () => {
        expect.assertions(1);
        const logInput = { message };
        const logEntry = logger.getLogEntry(logInput);
        expect(logEntry.level).toStrictEqual(originalLogEntryDefaults.level);
    });

    it('should throw if invalid level provided', () => {
        expect.assertions(1);
        const logInput = { message, level: 'debug' };
        expect(() => logger.getLogEntry(logInput)).toThrow('valid enumeration');
    });

    it('should populate logEntry with exitOnError if true/false provided', () => {
        expect.assertions(2); // eslint-disable-line no-magic-numbers
        const logInput = { message, exitOnError: true };
        let logEntry = logger.getLogEntry(logInput);
        expect(logEntry.exitOnError).toStrictEqual(logInput.exitOnError);

        logInput.exitOnError = false;
        logEntry = logger.getLogEntry(logInput);
        expect(logEntry.exitOnError).toStrictEqual(logInput.exitOnError);
    });

    it('should populate logEntry with default exitOnError if not provided', () => {
        expect.assertions(1);
        const logInput = { message };
        const logEntry = logger.getLogEntry(logInput);
        expect(logEntry.exitOnError).toStrictEqual(originalLogEntryDefaults.exitOnError);
    });

    it('should throw if invalid exitOnError value provided', () => {
        expect.assertions(1);
        const logInput = { message, exitOnError: 'blue' };
        expect(() => logger.getLogEntry(logInput)).toThrow('boolean');
    });

    it('should populate logEntry with isResult if true/false provided', () => {
        expect.assertions(2); // eslint-disable-line no-magic-numbers
        const logInput = { message, isResult: true };
        let logEntry = logger.getLogEntry(logInput);
        expect(logEntry.isResult).toStrictEqual(logInput.isResult);

        logInput.isResult = false;
        logEntry = logger.getLogEntry(logInput);
        expect(logEntry.isResult).toStrictEqual(logInput.isResult);
    });

    it('should populate logEntry with default isResult if not provided', () => {
        expect.assertions(1);
        const logInput = { message };
        const logEntry = logger.getLogEntry(logInput);
        expect(logEntry.isResult).toStrictEqual(originalLogEntryDefaults.isResult);
    });

    it('should throw if invalid isResults value provided', () => {
        expect.assertions(1);
        const logInput = { message, isResult: 'blue' };
        expect(() => logger.getLogEntry(logInput)).toThrow('boolean');
    });

    it('should populate logEntry with resultPrefix if provided', () => {
        expect.assertions(2); // eslint-disable-line no-magic-numbers
        const logInput = { message, resultPrefix: '-' };
        let logEntry = logger.getLogEntry(logInput);
        expect(logEntry.resultPrefix).toStrictEqual(logInput.resultPrefix);

        logInput.resultPrefix = 'foo';
        logEntry = logger.getLogEntry(logInput);
        expect(logEntry.resultPrefix).toStrictEqual(logInput.resultPrefix);
    });

    it('should populate logEntry with default resultPrefix if not provided', () => {
        expect.assertions(1);
        const logInput = { message };
        const logEntry = logger.getLogEntry(logInput);
        expect(logEntry.resultPrefix).toStrictEqual(originalLogEntryDefaults.resultPrefix);
    });

    it('should throw if invalid resultPrefix value provided', () => {
        expect.assertions(1);
        const logInput = { message, resultPrefix: true };
        expect(() => logger.getLogEntry(logInput)).toThrow('boolean');
    });
});

// eslint-disable-next-line max-lines-per-function
describe('log', () => {
    afterEach(() => {
        jest.restoreAllMocks();
    });

    const logWithSpies = (logEntry) => {
        const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
        const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});
        const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(() => {});
        const processExitSpy = jest.spyOn(process, 'exit').mockImplementation(() => {});

        logger.log(logEntry);

        return { consoleLogSpy, consoleWarnSpy, consoleErrorSpy, processExitSpy };
    };

    it('should call console.log with message if levels.info', () => {
        expect.assertions(1);
        const logEntry = { message, level: logger.levels.info };
        const result = logWithSpies(logEntry);
        expect(result.consoleLogSpy).toHaveBeenCalled(); // eslint-disable-line jest/prefer-called-with
    });

    it('should call console.warn with message if levels.warn', () => {
        expect.assertions(1);
        const logEntry = { message, level: logger.levels.warn };
        const result = logWithSpies(logEntry);
        expect(result.consoleWarnSpy).toHaveBeenCalled(); // eslint-disable-line jest/prefer-called-with
    });

    it('should call console.error with message and exit with error code if levels.error and exitOnError is true', () => {
        expect.assertions(4); // eslint-disable-line no-magic-numbers
        const logEntry = { message, level: logger.levels.error, exitOnError: true, errorCode: 123 };
        const result = logWithSpies(logEntry);
        // console.error should be called two times in this case
        const errorCalls = 2;
        expect(result.consoleErrorSpy).toHaveBeenCalledTimes(errorCalls);
        // The first call should be with the log message
        expect(result.consoleErrorSpy).toHaveBeenNthCalledWith(1, logEntry.message);
        // The second call should be with the exit message with error code
        expect(result.consoleErrorSpy).toHaveBeenNthCalledWith(errorCalls, expect.stringContaining(String(logEntry.errorCode)));
        expect(result.processExitSpy).toHaveBeenCalledWith(logEntry.errorCode);
    });

    it('should not exit if levels.error and exitOnError is false', () => {
        expect.assertions(2); // eslint-disable-line no-magic-numbers
        const logEntry = { message, level: logger.levels.error, exitOnError: false };
        const result = logWithSpies(logEntry);
        expect(result.consoleErrorSpy).toHaveBeenCalled(); // eslint-disable-line jest/prefer-called-with
        expect(result.processExitSpy).not.toHaveBeenCalled();
    });

    it('should not exit if not levels.error and exitOnError is true', () => {
        expect.assertions(2); // eslint-disable-line no-magic-numbers
        const logEntry = { message, level: logger.levels.warn, exitOnError: true };
        const result = logWithSpies(logEntry);
        expect(result.consoleWarnSpy).toHaveBeenCalled(); // eslint-disable-line jest/prefer-called-with
        expect(result.processExitSpy).not.toHaveBeenCalled();
    });

    it('should format message if isResult is true', () => {
        expect.assertions(1);
        const logEntry = { message, isResult: true };
        const result = logWithSpies(logEntry);
        // eslint-disable-next-line prefer-destructuring -- less intuitive
        const loggedMessage = result.consoleLogSpy.mock.calls[0][0];
        expect(loggedMessage).toStrictEqual(` ${originalLogEntryDefaults.resultPrefix} ${logEntry.message}`);
    });

    it('should format message with resultPrefix if isResult is true and resultPrefix provided', () => {
        expect.assertions(1);
        const logEntry = { message, isResult: true, resultPrefix: '-' };
        const result = logWithSpies(logEntry);
        // eslint-disable-next-line prefer-destructuring -- less intuitive
        const loggedMessage = result.consoleLogSpy.mock.calls[0][0];
        expect(loggedMessage).toStrictEqual(` ${logEntry.resultPrefix} ${logEntry.message}`);
    });

    it('should not format message if isResult is false', () => {
        expect.assertions(1);
        const logEntry = { message, isResult: false };
        const result = logWithSpies(logEntry);
        // eslint-disable-next-line prefer-destructuring -- less intuitive
        const loggedMessage = result.consoleLogSpy.mock.calls[0][0];
        expect(loggedMessage).toStrictEqual(logEntry.message);
    });
});

describe('resetLogEntryDefaults', () => {
    afterEach(() => {
        logger.resetLogEntryDefaults();
    });

    it('should return log entry with original defaults after reset', () => {
        expect.assertions(3); // eslint-disable-line no-magic-numbers
        // Get original log entry with default values for comparison
        const logEntryWithOriginalDefaults = logger.getLogEntry({ message });
        expect(logEntryWithOriginalDefaults).toMatchSnapshot();

        // Modify all settings to ensure that all are reset
        const modifiedLogEntryDefaults = {
            errorCode: 2,
            exitOnError: false,
            isResult: true,
            level: logger.levels.warn,
            resultPrefix: '-'
        };
        logger.setLogEntryDefaults(modifiedLogEntryDefaults);
        expect(logger.getLogEntry({ message })).toMatchSnapshot();

        logger.resetLogEntryDefaults();
        expect(logger.getLogEntry({ message })).toStrictEqual(logEntryWithOriginalDefaults);
    });
});

// eslint-disable-next-line max-lines-per-function
describe('setLogEntryDefaults', () => {
    const testSetLogEntryDefaults = (newDefaults) => {
        logger.setLogEntryDefaults(newDefaults);
        const logEntry = { message };
        const expectedResults = Object.assign({}, originalLogEntryDefaults, newDefaults, logEntry);
        expect(logger.getLogEntry(logEntry)).toStrictEqual(expectedResults);
    };

    afterEach(() => {
        logger.resetLogEntryDefaults();
    });

    it('should update default errorCode if specified', () => {
        expect.assertions(1);
        const updatedLogEntryDefaults = { errorCode: 3 };
        testSetLogEntryDefaults(updatedLogEntryDefaults);
    });

    it('should throw if default errorCode is not an integer', () => {
        expect.assertions(1);
        const updatedLogEntryDefaults = { errorCode: 'foo' };
        expect(() => logger.setLogEntryDefaults(updatedLogEntryDefaults)).toThrow('integer');
    });

    it('should update default exitOnError if specified', () => {
        expect.assertions(1);
        const updatedLogEntryDefaults = { exitOnError: false };
        testSetLogEntryDefaults(updatedLogEntryDefaults);
    });

    it('should throw if default exitOnError is not boolean', () => {
        expect.assertions(1);
        const updatedLogEntryDefaults = { exitOnError: 0 };
        expect(() => logger.setLogEntryDefaults(updatedLogEntryDefaults)).toThrow('boolean');
    });

    it('should update default isResult if specified', () => {
        expect.assertions(1);
        const updatedLogEntryDefaults = { isResult: true };
        testSetLogEntryDefaults(updatedLogEntryDefaults);
    });

    it('should throw if default isResult is not boolean', () => {
        expect.assertions(1);
        const updatedLogEntryDefaults = { isResult: 0 };
        expect(() => logger.setLogEntryDefaults(updatedLogEntryDefaults)).toThrow('boolean');
    });

    it('should update default level if specified', () => {
        expect.assertions(1);
        const updatedLogEntryDefaults = { level: logger.levels.warn };
        testSetLogEntryDefaults(updatedLogEntryDefaults);
    });

    it('should throw if default level is not valid', () => {
        expect.assertions(1);
        const updatedLogEntryDefaults = { level: 'foo' };
        expect(() => logger.setLogEntryDefaults(updatedLogEntryDefaults)).toThrow('valid enumeration');
    });


    it('should update default resultPrefix if specified', () => {
        expect.assertions(1);
        const updatedLogEntryDefaults = { resultPrefix: '-' };
        testSetLogEntryDefaults(updatedLogEntryDefaults);
    });

    it('should throw if default resultPrefix is not valid', () => {
        expect.assertions(1);
        const updatedLogEntryDefaults = { resultPrefix: 1 };
        expect(() => logger.setLogEntryDefaults(updatedLogEntryDefaults)).toThrow('string');
    });


    it('should update all defaults if specified', () => {
        expect.assertions(1);
        const updatedLogEntryDefaults = {
            errorCode: 2,
            exitOnError: false,
            isResult: true,
            level: logger.levels.warn,
            resultPrefix: '-'
        };
        testSetLogEntryDefaults(updatedLogEntryDefaults);
    });
});
